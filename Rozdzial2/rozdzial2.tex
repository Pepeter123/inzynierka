\chapter{Symulator Carla}
CARLA (Carl Learning to Act), czyli otwarty symulator jazdy miejskiej zosta³ stworzony do wspierania szkoleñ, treningów, tworzenia prototypów i walidacji autonomicznych systemów jazdy zarówno na poziomie percepcji jak i kontroli. System jest otwart¹ platform¹ stworzon¹ przez specjalistyczny zespó³ grafików cyfrowych. Obejmuje uk³ady urbanistyczne, modele pojazdów, budynki, pieszych oraz znaki drogowe. Symulacja umo¿liwia elastyczn¹ konfiguracjê, któr¹ mo¿na wykorzystaæ do strategicznego szkolenia jazdy, uzyskaæ wspó³rzêdne GPS, prêdkoœæ, przyspieszenie pojazdu czy te¿ informacje zwi¹zane z kolizj¹ b¹dŸ wykroczeniami drogowymi. Poza tym CARLA wykorzystuje warunki œrodowiskowe, jak warunki meteorologiczne oraz godzina. System wykorzystywany jest do manipulowania tras¹, któr¹ trzeba pokonaæ przy danych warunkach drogowych i œrodowiskowych~\cite{carla}. 


%=================================================================================================
\section{Architektura systemu Carla}
Symulator sk³ada siê ze skalowanej architektury klient - serwer. Serwer odpowiada za wszystko, co jest zwi¹zane z sam¹ symulacj¹, czyli renderowanie czujników, obliczanie fizyczne, aktualizacje stanu œwiata oraz aktorów. Z kolei strona klienta sk³ada siê z sumy modu³ów klienckich kontroluj¹cych logikê aktorów na scenie i ustalaj¹cych warunki panuj¹ce na œwiecie. Osi¹ga to poprzez wykorzystanie interfejsu API CARLA (w Pythonie lub C++), warstwie poœrednicz¹cej miêdzy serwerem a klientem, która stale ewoluuje, aby zapewniæ nowe funkcje (www.carla.org). Aby zrozumieæ system CARLA nale¿y poznaæ jego funkcje i elementy, dziêki którym osi¹ga wiele mo¿liwoœci. Poni¿ej wymieniono niektóre z nich:
\begin{itemize}
	\item Mened¿er ruchu, czyli wbudowany system, który przejmuje kontrole nad pojazdami. Dzia³a jako przewodnik dostarczony przez CARLA do odtworzenia œrodowisk miejskich z realistycznymi zachowaniami.
	\item Czujniki, na których polegaj¹ pojazdy podczas przekazywania informacji o swoim otoczeniu. S¹ to specyficzni aktorzy pod³¹czeni do pojazdu a dane, które otrzymuj¹ mog¹ byæ przechowywane i wyszukiwane w celu u³atwienia procesu. Obecnie projekt obs³uguje ich ró¿ne typy - kamery, radary, lidary, itd.
	\item Rejestrator, czyli funkcja s³u¿¹ca do odtwarzania symulacji krok po kroku dla ka¿dego aktora na œwiecie. Dziêki niej u¿ytkownik ma dostêp do ka¿dego miejsca na œwiecie w dowolnym momencie osi czasu. 
	\item Most ROS i implementacja Autoware, które zapewni¹ integracjê symulatora z innymi œrodowiskami uczenia siê.
	\item Otwarte zasoby, czyli u³atwienie tworzenia ró¿nych map miejskich z kontrol¹ warunków pogodowych i bibliotek¹ planów z szerokim zestawem aktorów do wykorzystania. 
	\item Scenariusz jazdy. Aby u³atwiæ proces uczenia siê pojazdów, CARLA zapewnia seriê tras opisuj¹cych ró¿ne sytuacje do iteracji. Stanowi¹ one równie¿ podstawê wyzwania CARLA, otwartego dla ka¿dego, kto chce przetestowaæ swoje rozwi¹zania i znaleŸæ siê w tabeli liderów.
\end{itemize}

\section{Mo¿liwoœci symulatora}
CARLA wykorzystywany jest do badania trzech podejœæ autonomicznej jazdy:

I - klasyczny, modu³owy potok, który obejmuje oparty na wizji modu³ percepcji, planer oparty na regu³ach i kontroler manewrów.

II - g³êboka sieæ odtwarzaj¹ca dane sensoryczne na polecenie przeszkolonych poprzez naukê naœladowania kierowców.

III - rozbudowana sieæ przeszkolona od pocz¹tku do koñca poprzez uczenie siê ze wzmocnieniem.

Symulator Carla oferuje u¿ytkownikowi mo¿liwoœci konfiguracji œrodowiska, w którym odbywa siê symulacja. Miêdzy innymi utworzenie w³asnej mapy rozwoju z elementami w postaci budynków, pojazdów oraz pieszych, czy te¿ korzystanie z gotowych œrodowisk utworzonych przez autorów projektu. Œrodowisko umo¿liwia symulowanie warunków pogodowych, oraz sterowanie sygnalizacj¹ œwietln¹ za pomoc¹ funkcji opisanych w jêzyku Python. W œrodowisku Carla, zaimplementowane s¹ tak¿e sensory, które odgrywaj¹ istotn¹ rolê w przypadku kolizji czy te¿ ustawiania atrybutów kamery. 

\subsection{Œwiat}


Mapa jest jednym z g³ównych elementów œwiata symulatora. Zawiera zarówno model 3D miejscowoœci, jak i definicjê dróg. Definicja dróg na mapie oparta jest na pliku OpenDRIVE, standardowym formacie definicji dróg z adnotacjami. Sposób, w jaki standard 1.4 OpenDRIVE definiuje drogi, pasy ruchu, skrzy¿owania itp. determinuje funkcjonalnoœæ API Pythona oraz uzasadnienie podejmowanych decyzji.

API Python dzia³a jako wysokopoziomowy system zapytañ do nawigacji po tych drogach. Jest ono stale rozwijane, aby zapewniæ szerszy zestaw narzêdzi

\begin{figure}[H]
	\centering
	\includegraphics[width=12cm]{Rysunki/Rozdzial2/map_1.png}
	\caption[Domyœlna mapa -  Town01]{Obraz mapy domyœlnej - Town01.}
	\label{fig:mapaTown01}
\end{figure} 

Domyœln¹ map¹ symulatora CARLA jest Town01 Rys. \ref{fig:mapaTown01}, bêd¹ca odwzorowaniem centrum du¿ego miasta. Program oferuje wiele gotowych map, z których mo¿na korzystaæ w celu przeprowadzenia eksperymentów, nie tylko podczas ró¿nych warunków pogodowych, ale równie¿ w rozmaitych œrodowiskach. Przyk³adem jest mapa Town04 Rys. \ref{fig:mapaTown04}, przedstawiaj¹ca ma³e miasteczko w górach, przy jeziorze.

\begin{figure}[H]
	\centering
	\includegraphics[width=12cm]{Rysunki/Rozdzial2/Town04.png}
	\caption[Mapa Town04]{Obraz mapy - Town04.}
	\label{fig:mapaTown04}
\end{figure} 

Œwiat symulatora zapewnia równie¿ aktorów. Aktorami s¹ nie tylko pojazdy i piesi, ale tak¿e czujniki, znaki drogowe, sygnalizacja œwietlna i widzowie. Bardzo wa¿ne jest, aby mieæ pe³ne zrozumienie, jak na nich operowaæ. Istnieje mo¿liwoœæ tworzenia aktorów zarówno rêczenia, poprzez funkcjê \verb|spawn_actor()| jak i z wykorzystaniem przyk³adowego programu zapewnionego przez developerów - \verb|generate_traffic.py|

\begin{figure}[H]
	\centering
	\includegraphics[width=12cm]{Rysunki/Rozdzial2/traffic.png}
	\label{fig:korek}
	\caption[Korek drogowy]{Obraz przedstawiaj¹cy symulacjê 30 pojazdów oraz 10 pieszych.}
\end{figure} 


\subsection{Sensory}


Sensor kolizji jest to czujnik, który rejestruje zdarzenie za ka¿dym razem, gdy jego aktor macierzysty zderzy siê z czymœ w œwiecie. Podczas jednego kroku symulacji mo¿e zostaæ wykrytych kilka kolizji. Aby zapewniæ wykrywanie kolizji z dowolnym obiektem, serwer tworzy ,,fa³szywych'' aktorów dla elementów takich jak budynki czy krzewy, dziêki czemu mo¿liwe jest pobranie znacznika semantycznego w celu ich identyfikacji.

Detektory kolizji nie posiadaj¹ ¿adnych konfigurowalnych atrybutów. \\


\begin{table}[H]
	\centering
	\begin{tabular}{|l|l|l|} 
		\hline
		Atrybuty        & Typ             & Opis                                                                                                            \\ 
		\hline
		\verb|frame|           & int             & Numer ramki, w której dokonano pomiaru.                                                                         \\ 
		\hline
		\verb|timestamp|       & double          & \begin{tabular}[c]{@{}l@{}}Czas symulacji pomiaru w\\sekundach od jej pocz¹tku.\end{tabular}                    \\ 
		\hline
		\verb|transform|       & carla.Transform & \begin{tabular}[c]{@{}l@{}}Po³o¿enie i obrót we wspó³rzêdnych \\œwiata czujnika w czasie pomiaru.\end{tabular}  \\ 
		\hline
		\verb|actor|           & carla.Actor     & \begin{tabular}[c]{@{}l@{}}Aktor, który zmierzy³ kolizjê \\(rodzic czujnika).\end{tabular}                      \\ 
		\hline
		\verb|other_actor|    & carla.Actor     & Aktor, z którym zderzy³ siê rodzic.                                                                             \\ 
		\hline
		\verb|normal_impulse| & carla.Vector3D  & Normalny impuls wynikaj¹cy z kolizji.                                                                           \\
		\hline
	\end{tabular}
	\caption{Atrybuty sensora kolizji}
\end{table}

\begin{figure}[h!]
	\centering
	\includegraphics[width=12cm]{Rysunki/Rozdzial2/collision_example.png}
	\label{fig:przyklad3D}
	 \caption[Sensor odpowiadaj¹cy za kolizje]{Przyk³adowy obraz kolizji ze s³upem.}
\end{figure}

Kolejnym sensorem jest kamera g³êbi. Kamera dostarcza surowe dane sceny koduj¹ce odleg³oœæ ka¿dego piksela od kamery (znane równie¿ jako bufor g³êbi lub z-bufor) w celu stworzenia mapy g³êbi elementów.

Obraz koduje wartoœæ g³êbi na piksel u¿ywaj¹c 3 kana³ów przestrzeni kolorów RGB, od mniej do bardziej znacz¹cych bajtów: R -> G -> B. Rzeczywista odleg³oœæ w metrach mo¿e byæ zdekodowana za pomoc¹: \newline

\begin{lstlisting}[style=praca]
	normalized = (R + G * 256 + B * 256 * 256) / (256 * 256 * 256 - 1)
	in_meters = 1000 * normalized
\end{lstlisting}


\begin{figure}[H]
	\centering
	\includegraphics[width=12cm]{Rysunki/Rozdzial2/depth_camera_oryginal.png}
	\label{fig:przyklad3D}
	\caption[Kamera g³êbi orygina³]{Oryginalny obraz pochodz¹cy z kamery g³êbi.}
\end{figure}

Wyjœciowy obraz CARLA.Image powinien zostaæ zapisany na dysk przy u¿yciu \verb|carla.colorConverter|, który zamieni odleg³oœæ zapisan¹ w kana³ach RGB na [0,1] float zawieraj¹cy odleg³oœæ, a nastêpnie przet³umaczy to na skalê szaroœci. Istniej¹ dwie opcje w \verb|carla.colorConverter|, aby uzyskaæ widok g³êbi: g³êbia w odcieniach szaroœci oraz g³êbokoœæ logarytmiczna. Precyzja jest milimetrowa w obu, ale podejœcie logarytmiczne zapewnia lepsze wyniki dla bli¿szych obiektów. Ponadto widocznoœæ jest lepsza dla u¿ytkownika.

\begin{figure}[H]
	\centering
	\includegraphics[width=12cm]{Rysunki/Rozdzial2/depth_gray_scale.png}
	\label{fig:przyklad3D}
	\caption[Kamera g³êbi po konwersji]{Obraz pochodz¹cy z kamery g³êbi po konwersji w odcieniach szaroœci.}
\end{figure} 


\begin{figure}[H]
	\centering
	\includegraphics[width=12cm]{Rysunki/Rozdzial2/depth_logarytmic.png}
	\label{fig:przyklad3D}
	\caption[Kamera g³êbi logarytmiczna]{Obraz pochodz¹cy z kamery g³êbi - logarytmiczny.}
\end{figure} 


Sensor GNSS (Global Navigation Satellite Systems) - podaje aktualn¹ pozycjê GNSS swojego obiektu nadrzêdnego. Jest ona obliczana poprzez dodanie pozycji metrycznej do pocz¹tkowej lokalizacji georeferencyjnej zdefiniowanej w definicji mapy OpenDRIVE

\begin{figure}[H]
	\centering
	\includegraphics[width=12cm]{Rysunki/Rozdzial2/gnss.png}
	\label{fig:przyklad3D}
	\caption[Sensor GNSS]{Widok sensora GNSS.}
\end{figure} 

Sensor IMU dostarcza natomiast miary, które akcelerometr, ¿yroskop i kompas mog³yby pobraæ dla obiektu nadrzêdnego. Dane s¹ pobierane z bie¿¹cego stanu obiektu.

\begin{figure}[H]
	\centering
	\includegraphics[width=12cm]{Rysunki/Rozdzial2/imu.png}
	\label{fig:przyklad3D}
	\caption[Sensor IMU]{Widok sensora IMU.}
\end{figure} 

Detektor wtargniêcia na pas ruchu 
Rejestruje zdarzenie za ka¿dym razem, gdy jego rodzic przekroczy oznaczenie pasa ruchu. Czujnik wykorzystuje dane drogowe dostarczane przez opis mapy OpenDRIVE, aby okreœliæ, czy pojazd macierzysty naje¿d¿a na inny pas ruchu, bior¹c pod uwagê przestrzeñ miêdzy ko³ami. Nale¿y jednak zwróciæ uwagê na pewne kwestie:

Rozbie¿noœci pomiêdzy plikiem OpenDRIVE a map¹ spowoduj¹ powstanie nieprawid³owoœci, takich jak przecinaj¹ce siê pasy ruchu, które nie s¹ widoczne na mapie.
Wyjœcie pobiera listê oznaczeñ przecinaj¹cych siê pasów: obliczenia s¹ wykonywane w OpenDRIVE i uwzglêdniaj¹ ca³¹ przestrzeñ pomiêdzy czterema ko³ami jako ca³oœæ. W zwi¹zku z tym, w tym samym czasie mo¿e byæ przekraczanych wiêcej ni¿ jeden pas ruchu.

\begin{figure}[H]
	\centering
	\includegraphics[width=12cm]{Rysunki/Rozdzial2/crossed_line.png}
	\label{fig:przyklad3D}
	\caption[Sensor pDrzeciêcia linii]{Obraz przyk³adu przeciêcia linii.}
\end{figure} 

Sensor LIDAR (eng. Light Detection and Ranging) - ten czujnik symuluje obracaj¹cy siê LIDAR zaimplementowany przy u¿yciu ray-casting. Punkty s¹ obliczane przez dodanie lasera dla ka¿dego kana³u rozmieszczonego w pionowym FOV. Obrót jest symulowany poprzez obliczenie k¹ta poziomego, o jaki obróci³ siê Lidar w danej klatce. Chmura punktów jest obliczana przez wykonanie ray-cast dla ka¿dego lasera w ka¿dym kroku.

Pomiar LIDAR-owy zawiera paczkê z wszystkimi punktami wygenerowanymi w przedziale czasu 1/FPS. Podczas tego interwa³u fizyka nie jest aktualizowana, wiêc wszystkie punkty w pomiarze odzwierciedlaj¹ ten sam "statyczny obraz" sceny.

Informacja z pomiaru LIDAR-owego jest zakodowana w postaci punktów 4D. Pierwsze trzy z nich to punkty przestrzenne we wspó³rzêdnych xyz, a ostatni to straty intensywnoœci podczas jazdy. Intensywnoœæ ta jest obliczana wed³ug nastêpuj¹cego wzoru:

\centerline{\large {$ I/I_0 = e^{-a*d}$ }}

Gdzie:
\begin{itemize}
	\item $a$ -- Oznacza wspó³czynnik t³umienia. Mo¿e on zale¿eæ od d³ugoœci fali czujnika oraz warunków atmosferycznych. Mo¿na go zmodyfikowaæ za pomoc¹ atrybutu LIDAR \verb|atmosphere_attenuation_rate|.
	\item $b$ -- Odleg³oœæ od punktu trafienia do czujnika.
\end{itemize}

Dla wiêkszego realizmu, punkty w chmurze mog¹ byæ zrzucane. Jest to prosty sposób na symulowanie strat spowodowanych zewnêtrznymi perturbacjami. Mo¿na to zrobiæ ³¹cz¹c dwa ró¿ne sposoby.

Pierwszym sposobem jest general drop-off, czyli proporcja punktów, które s¹ odpadane losowo. Jest to wykonywane przed œledzeniem, co oznacza, ¿e odpadaj¹ce punkty nie s¹ obliczane, a zatem poprawia wydajnoœæ. Jeœli wartoœæ ustawimy na 0,5, po³owa punktów zostanie zrzucona.
\begin{lstlisting}[style=praca]
	dropoff\_general\_rate = 0.5)
\end{lstlisting}

Drugim sposobem zaœ jest zrzucanie na podstawie intensywnoœci. Dla ka¿dego wykrytego punktu wykonywane jest dodatkowe zrzucanie z prawdopodobieñstwem opartym na obliczonej intensywnoœci. Prawdopodobieñstwo to jest okreœlane przez dwa parametry. \verb|dropoff_zero_intensity| jest prawdopodobieñstwem zrzucenia punktów o zerowej intensywnoœci. \verb|dropoff_intensity_limit| jest progiem intensywnoœci, powy¿ej którego punkty nie bêd¹ zrzucane. Prawdopodobieñstwo zrzucenia punktu w zakresie jest liniow¹ proporcj¹ opart¹ na tych dwóch parametrach. \\

Dodatkowo, atrybut \verb|noise_stddev| tworzy model szumu, aby symulowaæ nieoczekiwane odchylenia, które pojawiaj¹ siê w rzeczywistych czujnikach. Dla wartoœci dodatnich, ka¿dy punkt jest losowo perturbowany wzd³u¿ wektora promienia lasera. W rezultacie otrzymujemy czujnik LIDAR z doskona³ym pozycjonowaniem k¹towym, ale zaszumionym pomiarem odleg³oœci.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Rysunki/Rozdzial2/lidar.png}
	\label{fig:SensorLIDAR}
	\caption[Sensor LIDAR]{Obraz sensora LIDAR.}
\end{figure} 
Detektor przeszkód rejestruje zdarzenie za ka¿dym razem, gdy aktor macierzysty ma przed sob¹ przeszkodê. W celu przewidywania przeszkód, czujnik tworzy przed pojazdem macierzystym kszta³t kapsu³y i wykorzystuje go do sprawdzania, czy nie dochodzi do kolizji. Aby zapewniæ wykrywanie kolizji z ka¿dym rodzajem obiektu, serwer tworzy "fa³szywych" aktorów dla elementów takich jak budynki lub krzewy, dziêki czemu mo¿na pobraæ znacznik semantyczny w celu ich identyfikacji.

\begin{figure}[H]
	\centering
	\includegraphics[width=6cm]{Rysunki/Rozdzial2/obstacle_detector.png}
	\label{fig:SensorDetekcji}
	\caption[Sensor detekcji obiektów]{Obraz sensora detekcji obiektów.}
\end{figure} 

Sensor radaru jest to czujnik tworz¹cy widok sto¿kowy, który jest t³umaczony na mapê punktow¹ 2D elementów w zasiêgu wzroku i ich prêdkoœci wzglêdem czujnika. Mo¿e to byæ wykorzystane do kszta³towania elementów i oceny ich ruchu i kierunku. Ze wzglêdu na u¿ycie wspó³rzêdnych biegunowych, punkty bêd¹ skupione wokó³ œrodka widoku.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Rysunki/Rozdzial2/radar_sensor.png}
	\label{fig:przyklad3D}
	\caption[Sensor radaru]{Obraz sensora radaru.}
\end{figure} 

% biblio
%https://carla.readthedocs.io/en/latest/ref_sensors/
%

\subsection{Pogoda}

Pogoda nie jest klas¹ sam¹, lecz zbiorem parametrów dostêpnych w œwiecie symulatora CARLA. Parametryzacja zawiera w sobie elementy takie jak po³o¿enie s³oñca, zachmurzenie, wiatr, mg³ê, deszcz, œnieg a tak¿e wiele innych, aby umo¿liwiæ testowanie programu w ka¿dych mo¿liwych warunkach pogodowych. Aby zdefiniowaæ w³asn¹ pogodê u¿ywa siê klasy pomocniczej \verb|carla.WeathrrParameters| \\

\begin{lstlisting}[style=praca, caption={caption text}]
	weather = carla.WeatherParameters( cloudiness=80.0, precipitation=30.0, 
	sun_altitude_angle=70.0) world.set_weather(weather) 
	print(world.get_weather())
\end{lstlisting}

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Rysunki/Rozdzial2/soft_rain_sunset.png}
	\label{fig:lekki_deszcz_zachód}
	\caption[Lekki deszcz o zachodzie s³oñca]{Obraz przedstawiaj¹cy lekki deszcz o zachodzie s³oñca.}
\end{figure} 


Dostêpne s¹ równie¿ gotowe ustawienia pogody, które mo¿na bezpoœrednio zastosowaæ w symulacji jazdy samochodem. Lista zawieraj¹ca przygotowane warunki drogowe znajduje siê w klasie \verb|arla.WeathrrParameters|.

\begin{lstlisting}[style=praca]
	world.set_weather(carla.WeatherParameters.WetCloudySunset)
\end{lstlisting}

\begin{figure}[H]
	\centering
	\includegraphics[width=12cm]{Rysunki/Rozdzial2/cloudy_night.png}
	\label{fig:zachmurzona_noc}
	\caption[Zachmurzona noc]{Obraz przedstawiaj¹cy zachmurzon¹ noc.}
\end{figure} 

Istnieje równie¿ mo¿liwoœæ dostosowania pogody za pomoc¹ dwóch skryptów zapewnione przez symulator CARLA. 
S¹ to:
\begin{itemize}
	\item \verb|environment.py| (in PythonAPI/util) — Zapewnia dostêp do parametrów pogodowych i œwietlnych, dziêki czemu mo¿na je zmieniaæ w czasie rzeczywistym.
	\item \verb|dynamic_weather.py| (in PythonAPI/examples) — W³¹cza okreœlony cykl pogodowy przygotowany przez deweloperów dla ka¿dej mapy CARLA.
\end{itemize}

\begin{figure}[H]
	\centering
	\includegraphics[width=12cm]{Rysunki/Rozdzial2/hard_rain_noon.png}
	\label{fig:przyklad3D}
	\caption[Mocny deszcz w po³udnie]{Obraz przedstawiaj¹cy mocny deszcz w po³udnie.}
\end{figure} 
%https://carla.readthedocs.io/en/latest/core_world/#weather


\subsection{Oœwietlenie}

Œwiat³a uliczne w³¹czaj¹ siê automatycznie, gdy symulacja przechodzi w tryb nocny. Œwiat³a zosta³y umieszczone przez twórców mapy i s¹ dostêpne jako obiekty carla.Light. W³aœciwoœci takie jak kolor i natê¿enie œwiat³a mog¹ byæ dowolnie zmieniane. Zmienna \verb|light_state| typu \verb|carla.LightState| pozwala ustawiæ je wszystkie w jednym wywo³aniu.
Œwiat³a uliczne s¹ kategoryzowane za pomoc¹ ich atrybutu \verb|light_group|, typu \verb|carla.LightGroup|. Pozwala to na sklasyfikowanie œwiate³ jako œwiat³a uliczne, œwiat³a budynków... Aby obs³u¿yæ grupy œwiate³ w jednym wywo³aniu, mo¿na pobraæ instancjê \verb|carla.LightManager|

\begin{figure}[H]
	\centering
	\includegraphics[width=12cm]{Rysunki/Rozdzial2/street_lights.png}
	\label{fig:przyklad3D}
	\caption[Œwiat³a uliczne]{Obraz przedstawiaj¹cy œwiat³a uliczne.}
\end{figure} 

Œwiat³a pojazdu musz¹ byæ w³¹czane/wy³¹czane przez u¿ytkownika. Ka¿dy pojazd posiada zestaw œwiate³ wymienionych w \verb|carla.VehicleLightState|. Jak dot¹d, nie wszystkie pojazdy maj¹ zintegrowane œwiat³a. Poni¿ej znajduje siê lista tych, które s¹ dostêpne:
\begin{itemize}
	\item \verb|environment.py| (Rowery) — Wszystkie posiadaj¹ przednie i tylne œwiat³o pozycyjne.
	\item \verb|dynamic_weather.py| (Motocykle) — Modele Yamaha i Harley Davidson.
	\item \verb|dynamic_weather.py| (Samochody) - Audi TT, Chevrolet, Dodge (radiowóz), Audi e-tron, Lincoln, Mustang, Tesla 3S, Volkswagen T2 oraz nowi goœcie przybywaj¹cy do CARLA.
\end{itemize}

Œwiat³a pojazdu mog¹ byæ pobierane i aktualizowane w dowolnym momencie za pomoc¹ metod \verb|carla.Vehicle.get_light_state| i \verb|carla.Vehicle.set_light_state|. U¿ywaj¹ one operacji binarnych, aby dostosowaæ ustawienie œwiate³ ~\cite{carla}.

\begin{figure}[H]
	\centering
	\includegraphics[width=12cm]{Rysunki/Rozdzial2/vehicle_lights.png}
	\label{fig:przyklad3D}
	\caption[Œwiat³a pojazdu]{Obraz przedstawiaj¹cy œwiat³a pojazdu.}
\end{figure} 

\subsection{Wspó³rzêdne i jednostki miary}

\subsection*{Uk³ad wspó³rzêdnych}

Symulator CARLA \cite{carla} oraz Unreal Engine 4 (UE4) stosuj¹ lewoskrêtny uk³ad wspó³rzêdnych kartezjañski z osi¹ Z skierowan¹ w górê (Z-up). Oznacza to:

\begin{itemize}
	\item \textbf{Oœ X}: skierowana do przodu (forward).
	\item \textbf{Oœ Y}: skierowana w prawo (right).
	\item \textbf{Oœ Z}: skierowana w górê (up).
\end{itemize}

Punkt (0, 0, 0) to pocz¹tek uk³adu wspó³rzêdnych, zwany \textit{origin}. Wartoœci dodatnie na osi X oznaczaj¹ ruch do przodu, na osi Y w prawo, a na osi Z w górê \cite{devEpicgames}.

\subsection*{Jednostki miary}

W obu œrodowiskach:

\begin{itemize}
	\item \textbf{1 jednostka (unit)} odpowiada \textbf{1 centymetrowi} w rzeczywistoœci.
	\item \textbf{1 metr} = \textbf{100 jednostek}.
	\item \textbf{1 kilometr} = \textbf{100\,000 jednostek}.
	\item \textbf{1 cal} = \textbf{2,54 jednostki}.
	\item \textbf{1 stopa} = \textbf{30,48 jednostki}.
\end{itemize}

Oznacza to, ¿e zarówno w UE4, jak i w CARLA, 1 jednostka w grze to 1 cm w œwiecie rzeczywistym \cite{devEpicgamesUnits}.

\subsection*{Pozycjonowanie obiektów i punkt (0, 0, 0)}

W UE4 i CARLA:

\begin{itemize}
	\item \textbf{Punkt (0, 0, 0)}: znajduje siê w centrum œwiata gry, zwykle w miejscu, gdzie zaczyna siê scena.
	\item \textbf{Pozycjonowanie obiektów}: odbywa siê poprzez okreœlenie ich lokalizacji wzglêdem tego punktu, np. \texttt{actor.set\_location(FVector(x, y, z))}.
\end{itemize}

\subsection*{Podsumowanie}

\begin{itemize}
	\item \textbf{Uk³ad wspó³rzêdnych}: Lewoskrêtny, Z-up.
	\item \textbf{Punkt (0, 0, 0)}: Centrum œwiata gry.
	\item \textbf{Jednostka miary}: 1 jednostka = 1 cm w rzeczywistoœci.
\end{itemize}

\section{Instalacja symulatora Carla}

\subsection{Wymagania sprzêtowe}

Rekomendowana specyfikacja komputera dla najnowszej wersji symulatora CARLA  0.9.13 prezentuje siê nastêpuj¹co:
\begin{itemize}
	\item \verb|Procesor| Intel i7 gen 9th - 11th / Intel i9 gen 9th - 11th / AMD ryzen 7 / AMD ryzen 9
	\item \verb|Iloœæ pamiêci RAM| +16 GB pamiêci RAM
	\item \verb|Iloœæ miejsca na dysku| 130GB
	\item \verb|Karta graficzna| najlepiej z 6GB lub 8GB pamiêci  VRAM np. NVIDIA RTX 2070 / NVIDIA RTX 2080 / NVIDIA RTX 3070, NVIDIA RTX 3080 lub nowsze
	\item \verb|System operacyjny| Ubuntu 18.04/ 20.04/ 22.04/ Windows 10
\end{itemize}

\subsection{Instalacja i konfiguracja dla systemu Ubuntu}

Pierwszym etapem instalacji CARLA jest przygotowanie systemu. W pierwszej kolejnoœci system powinien zostaæ zaktualizowany, a niezbêdne pakiety zainstalowane:

\begin{lstlisting}[caption={Aktualizacja systemu}]
	sudo apt update
	sudo apt upgrade
\end{lstlisting}

Nastêpnie musz¹ zostaæ zainstalowane zale¿noœci wymagane przez CARLA:

\begin{lstlisting}[caption={Instalacja zale¿noœci}]
	sudo apt install build-essential clang cmake git libcurl4-openssl-dev libssl-dev \
	libsqlite3-dev libudev-dev pkg-config python3-dev python3-pip \
	python3-setuptools python3-wheel qt5-qmake qtbase5-dev libqt5core5a \
	libqt5gui5 libqt5widgets5 libprotobuf-dev protobuf-compiler \
	libsdl2-dev libpng-dev libjpeg-dev libtiff-dev libgtk-3-dev \
	libassimp-dev libblas-dev liblapack-dev libboost-all-dev \
	libopenblas-dev libatlas-base-dev libeigen3-dev
\end{lstlisting}

Dodatkowo, konieczne jest zainstalowanie jêzyka Python oraz mened¿era pakietów PIP:

\begin{lstlisting}[caption={Instalacja Pythona i PIP}]
	sudo apt install python3 python3-pip
	python3 -m pip install --upgrade pip
\end{lstlisting}

\subsection{Instalacja Unreal Engine}

Ze wzglêdu na to, ¿e CARLA jest oparta na silniku Unreal Engine, konieczne jest jego zainstalowanie. Proces ten mo¿e zostaæ przeprowadzony za pomoc¹ Epic Games Launcher ~\cite{unreal-engine}.

\begin{enumerate}
	\item Nale¿y za³o¿yæ konto na stronie \texttt{https://www.epicgames.com/}.
	\item Nastêpnie nale¿y pobraæ i zainstalowaæ Epic Games Launcher.
	\item Po instalacji wymagane jest zalogowanie siê i przejœcie do zak³adki \texttt{Library}.
	\item Nale¿y wybraæ odpowiedni¹ wersjê Unreal Engine (zalecana 4.27 lub nowsza) i przeprowadziæ instalacjê.
	\item Po zakoñczeniu instalacji Unreal Engine powinien zostaæ uruchomiony za poœrednictwem Epic Games Launcher.
\end{enumerate}

\subsection{Pobranie Ÿróde³ CARLA i kompilacja}

Aby pobraæ CARLA, repozytorium musi zostaæ sklonowane z GitHub:

\begin{lstlisting}[caption={Pobieranie Ÿróde³ CARLA}]
	cd ~
	git clone https://github.com/carla-simulator/carla.git
	cd carla
\end{lstlisting}

Kolejnym krokiem jest przejœcie do katalogu zawieraj¹cego projekt Unreal Engine dla CARLA:

\begin{lstlisting}[caption={Przechodzenie do folderu Unreal Engine dla CARLA}]
	cd Unreal/CarlaUE4
\end{lstlisting}

Nastêpnie konieczne jest uruchomienie Unreal Engine w celu konfiguracji projektu:

\begin{lstlisting}[caption={Uruchamianie Unreal Engine}]
	~/UnrealEngine/Engine/Binaries/Linux/UE4Editor CarlaUE4.uproject
\end{lstlisting}

Po uruchomieniu Unreal Engine nale¿y wybraæ opcjê \texttt{Generate Visual Studio project files} i zamkn¹æ edytor.

W kolejnym kroku wymagane jest powrócenie do terminala i przeprowadzenie kompilacji:

\begin{lstlisting}[caption={Kompilacja CARLA}]
	make
\end{lstlisting}

\subsection{Uruchomienie symulatora CARLA}

Po zakoñczeniu kompilacji symulator CARLA mo¿e zostaæ uruchomiony:

\begin{lstlisting}[caption={Uruchamianie CARLA}]
	cd ~/carla/Unreal/CarlaUE4/Binaries/Linux
	./CarlaUE4
\end{lstlisting}

Po pomyœlnym uruchomieniu symulatora powinien ukazaæ siê obraz mapy domyœlnej widocznym na Rys. \ref{fig:mapaTown01}. Korzystanie z API CARLA w Pythonie Mo¿na rozpocz¹æ poprzez instalacjê odpowiednich pakietów:

\begin{lstlisting}[caption={Instalacja zale¿noœci Pythona}]
	pip3 install carla
\end{lstlisting}

Aby zweryfikowaæ poprawnoœæ dzia³ania, mo¿na uruchomiæ przyk³adowy skrypt Pythona:

\begin{lstlisting}[caption={Uruchamianie przyk³adowego skryptu}]
	cd ~/carla/PythonAPI/examples
	python spawn_npc.py
\end{lstlisting}

Je¿eli wszystkie kroki zosta³y wykonane poprawnie, symulator CARLA powinien dzia³aæ, a skrypt Python powinien uruchomiæ siê bez problemów.

\section{Skrypt do manualnego sterowania w symulatorze CARLA}
Plik \verb|manual_control.py| w symulatorze CARLA jest skryptem umo¿liwiaj¹cym rêczne sterowanie pojazdem za pomoc¹ klawiatury oraz myszy. Stanowi on jedno z podstawowych narzêdzi do testowania, eksploracji oraz analizy œrodowiska symulacyjnego, dostarczaj¹c u¿ytkownikowi pe³n¹ kontrolê nad pojazdem w czasie rzeczywistym.

\subsection{Struktura skryptu}
Plik \verb|manual_control.py| zosta³ zaprojektowany modularnie i obejmuje kilka kluczowych sekcji, z których ka¿da realizuje specyficzny etap dzia³ania aplikacji:
\begin{itemize}
	\item \textbf{Importowanie bibliotek oraz konfiguracja klienta CARLA} – inicjalizacja po³¹czenia z serwerem symulacji oraz za³adowanie niezbêdnych bibliotek zewnêtrznych, takich jak \verb|pygame| czy \verb|carla|.
	\item \textbf{Inicjalizacja œrodowiska i pojazdu} – stworzenie œwiata symulacyjnego, pojazdu oraz pod³¹czenie odpowiednich czujników.
	\item \textbf{Obs³uga wejœcia u¿ytkownika} – monitorowanie urz¹dzeñ wejœciowych (klawiatura, mysz) za pomoc¹ biblioteki \verb|pygame|.
	\item \textbf{G³ówna pêtla gry (game loop)} – ci¹g³e przetwarzanie zdarzeñ, aktualizacja stanu œwiata oraz renderowanie obrazu.
	\item \textbf{Zakoñczenie i czyszczenie zasobów} – prawid³owe usuniêcie wszystkich aktorów i zwolnienie zasobów systemowych.
\end{itemize}
Ka¿dy z tych etapów pe³ni fundamentaln¹ rolê w zapewnieniu poprawnej i wydajnej pracy symulacji.

\subsection{Logika dzia³ania pliku \texttt{manual\_control.py}}
Plik \verb|manual_control.py| realizuje pe³ny cykl ¿ycia aplikacji symulacyjnej: od inicjalizacji œrodowiska, przez obs³ugê sterowania rêcznego, a¿ po prawid³owe zakoñczenie symulacji. Jego struktura zosta³a przedstawiona na schemacie blokowym (rysunek \ref{fig:manual_control_diagram}).

\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\textwidth]{Rysunki/Rozdzial2/diagram_manual_control.png}
	\caption{Schemat blokowy dzia³ania pliku \texttt{manual\_control.py}}
	\label{fig:manual_control_diagram}
\end{figure}

G³ówne komponenty systemu:
\begin{itemize}
	\item \textbf{Main Loop} – odpowiada za przetwarzanie zdarzeñ wejœciowych, aktualizacjê stanu œwiata oraz renderowanie grafiki.
	\item \textbf{CameraManager} – umo¿liwia zarz¹dzanie widokami kamer i przetwarzanie danych z czujników wizualnych.
	\item \textbf{World} – zarz¹dza ca³ym œwiatem symulacji, w tym pojazdem u¿ytkownika, pogod¹ oraz czujnikami.
	\item \textbf{KeyboardControl} – przetwarza sygna³y z klawiatury i przek³ada je na konkretne komendy steruj¹ce pojazdem.
	\item \textbf{Sensors} – obejmuje wszystkie dostêpne czujniki w symulatorze (kamera RGB, czujniki kolizji, lane invasion sensor, GNSS, IMU, radar).
	\item \textbf{HUD (Heads-Up Display)} – odpowiedzialny za prezentowanie informacji o stanie symulacji w formie graficznej.
\end{itemize}

Komunikacja miêdzy tymi komponentami odbywa siê w sposób asynchroniczny, zapewniaj¹c p³ynne dzia³anie symulacji oraz wysok¹ responsywnoœæ interfejsu u¿ytkownika.
\subsection{Pêtla gry (Game Loop)}
G³ówna pêtla symulacyjna, realizowana w funkcji \verb|game_loop()|, odpowiedzialna jest za cykliczne aktualizowanie stanu œrodowiska oraz reagowanie na zdarzenia wejœciowe. Jej g³ówne zadania obejmuj¹:

\begin{enumerate}
	\item \textbf{Odczyt stanu klawiatury} – umo¿liwia wykrywanie naciœniêtych klawiszy w czasie rzeczywistym.
	\item \textbf{Analizê wejœcia u¿ytkownika} – wywo³anie funkcji \verb|parse_control_input()| celem przetworzenia danych wejœciowych.
	\item \textbf{Zastosowanie kontroli do pojazdu} – przekazanie utworzonych komend steruj¹cych do pojazdu poprzez metodê \verb|apply_control()|.
	\item \textbf{Synchronizacjê klatek} – zapewnienie p³ynnoœci animacji przy u¿yciu \verb|clock.tick(30)|, co ustala sta³¹ liczbê 30 FPS.
\end{enumerate}

Przyk³adowy kod realizacji pêtli gry:

\begin{lstlisting}[style=pythonColor, emph={Client, get_world, VehicleControl, Clock, get_pressed, parse_control_input, get_actors, apply_control, tick}, caption={Przyk³ad kodu pêtli gry - Game Loop}]
	def main():
	client = carla.Client('localhost', 2000)
	world = client.get_world()
	control = carla.VehicleControl()
	
	pygame.init()
	clock = pygame.time.Clock()
	
	try:
	while True:
	keys = pygame.key.get_pressed()
	control = parse_control_input(keys)
	
	vehicle = world.get_actors().filter('vehicle.*')[0]
	vehicle.apply_control(control)
	
	clock.tick(30)
	except KeyboardInterrupt:
	pass
\end{lstlisting}

\subsection{Tryb asynchroniczny i synchroniczny}

Symulator CARLA umo¿liwia uruchamianie œrodowiska symulacyjnego w dwóch podstawowych trybach: asynchronicznym oraz synchronicznym. Zrozumienie ich ró¿nic i sposobu implementacji w kodzie Ÿród³owym, a szczególnie w kontekœcie pêtli g³ównej symulacji, ma kluczowe znaczenie dla skutecznej integracji z zewnêtrznymi systemami przetwarzania, takimi jak np. algorytmy detekcji obiektów w czasie rzeczywistym.
W trybie \textbf{asynchronicznym}, który jest domyœlnym ustawieniem symulatora, œwiat gry jest aktualizowany niezale¿nie od klienta. Oznacza to, ¿e symulacja dzia³a z w³asn¹ czêstotliwoœci¹ i nie oczekuje na sygna³y od zewnêtrznych aplikacji. Dane z sensorów, takich jak kamery czy lidary, mog¹ byæ wiêc niespójne wzglêdem stanu symulacji w momencie ich odczytu, co mo¿e skutkowaæ niedok³adnoœciami podczas analizy lub uczenia modeli \cite{carla}.

W przeciwieñstwie do tego, tryb \textbf{synchroniczny} pozwala klientowi kontrolowaæ tempo symulacji. W tym trybie ka¿da klatka symulacji jest generowana dopiero po wywo³aniu metody \verb|world.tick()| przez klienta. Dziêki temu mo¿liwe jest pe³ne zsynchronizowanie stanu œwiata z danymi z sensorów, co jest niezbêdne w wielu zastosowaniach wymagaj¹cych precyzji, takich jak testowanie algorytmów percepcji w pojazdach autonomicznych.

\subsection{Implementacja synchronizacji w \texttt{manual\_control.py}}

Tryb synchroniczny jest aktywowany w pliku \verb|manual_control.py| poprzez odpowiedni¹ konfiguracjê ustawieñ œwiata gry. Kluczowy fragment kodu odpowiedzialny za aktywacjê tego trybu przedstawia siê nastêpuj¹co:

\begin{verbatim}
	settings = world.get_settings()
	settings.synchronous_mode = True
	settings.fixed_delta_seconds = 0.05
	world.apply_settings(settings)
\end{verbatim}

Ustawienie parametru \verb|synchronous_mode| na \verb|True| oraz okreœlenie \verb|fixed_delta_seconds| (np. 0.05 s odpowiadaj¹ce 20 FPS) pozwala osi¹gn¹æ spójne, deterministyczne zachowanie symulacji. W przypadku uruchomienia skryptu z parametrem \verb|--sync|, aktywowany zostaje synchroniczny mechanizm sterowania symulacj¹.

\subsection{Analiza pêtli g³ównej \texttt{game\_loop()}}

G³ówna pêtla symulacji, zdefiniowana w funkcji \verb|game_loop()|, realizuje krokow¹ kontrolê nad œwiatem gry. Przyk³adowy fragment tej pêtli wygl¹da nastêpuj¹co:

\begin{verbatim}
	while True:
	if args.sync:
	sim_world.tick()
	clock.tick_busy_loop(60)
	if controller.parse_events(client, world, clock, args.sync):
	return
	world.tick(clock)
	world.render(display)
	pygame.display.flip()
\end{verbatim}

Jej dzia³anie mo¿na roz³o¿yæ na kilka kroków:

\begin{enumerate}
	\item \textbf{Synchronizacja z serwerem:} Jeœli aktywowany zosta³ tryb synchroniczny (\verb|args.sync|), klient wywo³uje metodê \verb|sim_world.tick()|, co inicjuje przetworzenie jednej klatki symulacji po stronie serwera.
	\item \textbf{Ograniczenie liczby klatek:} Funkcja \verb|clock.tick_busy_loop(60)| ogranicza liczbê iteracji pêtli do 60 na sekundê, a tak¿e oblicza czas miêdzy kolejnymi iteracjami.
	\item \textbf{Przetwarzanie zdarzeñ wejœciowych:} Metoda \verb|parse_events(...)| obs³uguje zdarzenia Pygame, takie jak naciœniêcia klawiszy, zamkniêcie aplikacji itp. Jeœli u¿ytkownik zainicjuje zakoñczenie programu, pêtla zostaje przerwana.
	\item \textbf{Aktualizacja stanu lokalnego:} Wywo³anie \verb|world.tick(clock)| s³u¿y do wewnêtrznej aktualizacji komponentów klienta – takich jak interfejs u¿ytkownika (HUD), kamery czy dane z sensorów. W trybie synchronicznym nie powoduje ono przesuniêcia œwiata gry, lecz jedynie uzupe³nia dane ju¿ wygenerowane przez \verb|sim_world.tick()|.
	\item \textbf{Renderowanie:} Funkcja \verb|world.render(display)| przygotowuje obraz do wyœwietlenia, a \verb|pygame.display.flip()| aktualizuje ekran, pokazuj¹c najnowsz¹ ramkê wraz z interfejsem graficznym.
\end{enumerate}

Dziêki takiej konstrukcji pêtli mo¿liwa jest pe³na kontrola nad przebiegiem symulacji. Co istotne, w trybie synchronicznym to klient dyktuje tempo, co jest kluczowe w zastosowaniach zwi¹zanych z uczeniem maszynowym i testowaniem detekcji obiektów (np. YOLO), gdzie wymagana jest spójnoœæ miêdzy stanem œrodowiska a danymi sensorycznymi.

\subsection{Znaczenie dla integracji z algorytmami zewnêtrznymi}

Zastosowanie trybu synchronicznego jest szczególnie istotne w kontekœcie integracji z zewnêtrznymi algorytmami analizy danych, np. systemami opartymi o YOLO. W takich przypadkach przetwarzanie obrazu musi byæ zgodne ze stanem symulacji, aby wykrywane obiekty odpowiada³y ich rzeczywistej pozycji i prêdkoœci. Brak synchronizacji mo¿e prowadziæ do b³êdnych detekcji i zaburzenia procesu wnioskowania.


\subsection{Sterowanie pojazdem z poziomu klawiatury}

Jednym z g³ównych elementów interakcji u¿ytkownika z pojazdem w symulatorze CARLA jest sterowanie przy pomocy klawiatury. W tym celu skrypt \texttt{manual\_control.py} wykorzystuje bibliotekê \texttt{pygame}, która pozwala na obs³ugê wejœcia u¿ytkownika i monitorowanie stanu klawiszy. G³ówna funkcja odpowiedzialna za to zadanie to \texttt{parse\_control\_input()}, która analizuje naciœniête klawisze i na ich podstawie dostosowuje parametry sterowania pojazdem.

Przyk³adowy kod do obs³ugi sterowania pojazdem:

\begin{lstlisting}[style=pythonColor, emph={parse\_control\_input, get\_pressed, VehicleControl}, caption={Przyk³adowy kod w jêzyku Python odpowiedzialny za sterowanie pojazdem z klawiatury}]
	import pygame
	
	def parse_control_input():
	keys = pygame.key.get_pressed()  # Pobranie stanu klawiszy
	control = carla.VehicleControl()  # Obiekt sterowania pojazdem
	
	if keys[pygame.K_w]:  # Przyspieszanie (gaz)
	control.throttle = 1.0  
	if keys[pygame.K_s]:  # Hamowanie
	control.brake = 1.0  
	if keys[pygame.K_a]:  # Skrêt w lewo
	control.steer = -1.0  
	if keys[pygame.K_d]:  # Skrêt w prawo
	control.steer = 1.0  
	
	return control  # Zwrócenie obiektu sterowania
\end{lstlisting}

Opis kodu:

\begin{itemize}
	\item \textbf{Pobranie stanu klawiszy:} Funkcja \texttt{pygame.key.get\_pressed()} zwraca tablicê wartoœci logicznych dla wszystkich klawiszy, umo¿liwiaj¹c interakcjê z pojazdem. Wartoœæ \texttt{True} oznacza, ¿e dany klawisz jest wciœniêty.
	\item \textbf{Tworzenie obiektu sterowania:} Obiekt \texttt{carla.VehicleControl()} jest u¿ywany do przekazywania parametrów sterowania do symulowanego pojazdu. Wœród w³aœciwoœci tego obiektu znajduj¹ siê:
	\begin{itemize}
		\item \texttt{throttle} – stopieñ przyspieszenia (wartoœæ od 0.0 do 1.0),
		\item \texttt{brake} – stopieñ hamowania (wartoœæ od 0.0 do 1.0),
		\item \texttt{steer} – k¹t skrêtu (wartoœæ od -1.0 do 1.0, gdzie -1.0 oznacza skrêt w lewo, a 1.0 w prawo).
	\end{itemize}
	\item \textbf{Sterowanie pojazdem:} Na podstawie wciœniêtych klawiszy funkcja ustawia odpowiednie wartoœci w obiekcie \texttt{control}. Na przyk³ad:
	\begin{itemize}
		\item \texttt{W} powoduje przyspieszanie pojazdu (\texttt{throttle = 1.0}),
		\item \texttt{S} uruchamia hamowanie (\texttt{brake = 1.0}),
		\item \texttt{A} i \texttt{D} steruj¹ k¹tem skrêtu.
	\end{itemize}
	\item \textbf{Zwrócenie obiektu sterowania:} Po przetworzeniu stanu klawiszy funkcja zwraca obiekt \texttt{control}, który jest nastêpnie u¿ywany do sterowania pojazdem w symulacji.
\end{itemize}

\subsection{Pêtla gry - Game Loop}

W symulatorze CARLA plik \texttt{manual\_control.py} zawiera funkcjê \texttt{game\_loop()}, która pe³ni rolê g³ównej pêtli symulacyjnej, odpowiedzialnej za interakcjê u¿ytkownika ze œwiatem symulowanym oraz za aktualizacjê i renderowanie otoczenia w czasie rzeczywistym. Funkcja ta inicjalizuje wszystkie niezbêdne komponenty œrodowiska, nawi¹zuje po³¹czenie z serwerem CARLA, a nastêpnie wykonuje ci¹g³¹ iteracjê (pêtlê nieskoñczon¹), a¿ do zakoñczenia programu przez u¿ytkownika. W przypadku symulatora CARLA pêtla gry wykonuje nastêpuj¹ce kroki:

\begin{enumerate}
	\item \textbf{Pobranie stanu klawiszy:} Funkcja \texttt{pygame.key.get\_pressed()} umo¿liwia monitorowanie stanu wszystkich klawiszy na klawiaturze, co pozwala na kontrolowanie pojazdu. Odczyt stanu klawiszy jest kluczowy do sterowania ruchem pojazdu (np. przyspieszanie, hamowanie, skrêt w lewo lub prawo).
	\item \textbf{Przetwarzanie wejœcia u¿ytkownika:} Funkcja \texttt{parse\_control\_input(keys)} analizuje stan klawiszy i na tej podstawie ustawia odpowiednie parametry sterowania pojazdem. Na przyk³ad, jeœli u¿ytkownik wciœnie klawisz \texttt{W}, wartoœæ \texttt{throttle} zostaje ustawiona na \texttt{1.0}, co powoduje przyspieszenie pojazdu.
	\item \textbf{Zastosowanie kontroli do pojazdu:} Funkcja \texttt{vehicle.apply\_control(control)} wysy³a skonfigurowany obiekt sterowania do pojazdu, aby ten wykona³ odpowiedni¹ akcjê (np. przyspieszenie, hamowanie, skrêt).
	\item \textbf{Kontrola liczby klatek na sekundê:} Funkcja \texttt{clock.tick(30)} zapewnia, ¿e symulacja nie bêdzie dzia³a³a za szybko, umo¿liwiaj¹c p³ynne sterowanie pojazdem i zachowanie w³aœciwej synchronizacji w grze.
\end{enumerate}

Przyk³adowy fragment kodu pêtli gry:

\begin{lstlisting}[style=pythonColor, emph={Client, get_world, VehicleControl, Clock, get_pressed, parse_control_input, get_actors, apply_control, tick}, caption={Przyk³ad kodu pêtli gry - Game Loop}]
	def main():
	client = carla.Client('localhost', 2000)  # Inicjalizacja klienta CARLA
	world = client.get_world()  # Pobranie œwiata symulacji
	control = carla.VehicleControl()  # Obiekt sterowania pojazdem
	
	pygame.init()  # Inicjalizacja pygame
	clock = pygame.time.Clock()  # Inicjalizacja zegara dla kontrolowania FPS
	
	try:
	while True:
	keys = pygame.key.get_pressed()  # Pobieranie stanu klawiszy
	control = parse_control_input(keys)  # Analiza wejœcia od u¿ytkownika
	
	vehicle = world.get_actors().filter('vehicle.*')[0]  # Pobranie pojazdu
	vehicle.apply_control(control)  # Zastosowanie kontroli do pojazdu
	
	clock.tick(30)  # Ograniczenie liczby klatek na sekundê
	except KeyboardInterrupt:
	pass
\end{lstlisting}

\subsection{Sterowanie pojazdem za pomoc¹ klawiatury}
Sterowanie pojazdem odbywa siê g³ównie przy pomocy klawiatury, wykorzystuj¹c bibliotekê \verb|pygame| do obs³ugi zdarzeñ wejœciowych. G³ówn¹ funkcj¹ odpowiedzialn¹ za przetwarzanie sygna³ów od u¿ytkownika jest \verb|parse_control_input()|, która analizuje aktualny stan klawiatury i przek³ada go na komendy steruj¹ce pojazdem.

\begin{lstlisting}[style=pythonColor, emph={parse_control_input, get_pressed, VehicleControl}, caption={Przyk³adowy kod obs³ugi sterowania pojazdem z klawiatury}]
	import pygame
	
	def parse_control_input():
	keys = pygame.key.get_pressed()
	control = carla.VehicleControl()
	
	if keys[pygame.K_w]:
	control.throttle = 1.0
	if keys[pygame.K_s]:
	control.brake = 1.0
	if keys[pygame.K_a]:
	control.steer = -1.0
	if keys[pygame.K_d]:
	control.steer = 1.0
	
	return control
\end{lstlisting}

\noindent
Opis kodu:
\begin{itemize}
	\item \textbf{Pobieranie stanu klawiszy} – funkcja \verb|pygame.key.get_pressed()| umo¿liwia detekcjê aktualnie wciœniêtych klawiszy.
	\item \textbf{Tworzenie obiektu sterowania} – \verb|carla.VehicleControl| umo¿liwia ustawienie parametrów takich jak przyspieszenie, hamowanie czy skrêt.
	\item \textbf{Ustawianie parametrów} – przypisanie odpowiednich wartoœci do w³aœciwoœci \verb|throttle|, \verb|brake| i \verb|steer| w zale¿noœci od interakcji u¿ytkownika.
	\item \textbf{Zwrócenie obiektu} – gotowy obiekt sterowania zostaje przes³any do funkcji steruj¹cej pojazdem w œwiecie symulacyjnym.
\end{itemize}

\subsection{Czyszczenie zasobów (Cleanup)}
Po zakoñczeniu dzia³ania symulacji niezbêdne jest prawid³owe usuniêcie wszystkich aktorów, aby zwolniæ pamiêæ oraz unikn¹æ potencjalnych b³êdów.

Proces ten obejmuje:
\begin{itemize}
	\item \textbf{Pobranie aktorów} – funkcja \verb|world.get_actors()| zwraca wszystkie aktywne obiekty w œwiecie.
	\item \textbf{Zniszczenie aktorów} – poprzez iteracyjne wywo³ywanie metody \verb|destroy()| na ka¿dym z aktorów.
\end{itemize}

Przyk³adowy kod funkcji czyszcz¹cej:

\begin{lstlisting}[style=pythonColor, emph={cleanup, get_actors, destroy}, caption={Kod funkcji odpowiedzialnej za czyszczenie zasobów}]
	def cleanup(world):
	actors = world.get_actors()
	for actor in actors:
	actor.destroy()
\end{lstlisting}

Poprawne czyszczenie zasobów zapewnia optymaln¹ wydajnoœæ symulacji i umo¿liwia jej wielokrotne uruchamianie bez ryzyka narastania b³êdów pamiêciowych.